#pragma kernel CSMain

uniform RWTexture2D<float4> output;

float4x4 camera_to_world;
float4x4 inverse_projection;

struct Ray
{
    float3 origin;
    float3 direction;
};

float2 getOutputDimensions()
{
    float2 dimension;
    output.GetDimensions(dimension.x, dimension.y);
    return dimension;
}

Ray calculateRay(uint2 screen_pos)
{
    Ray r;

    float2 uv = screen_pos.xy / getOutputDimensions() * 2 - 1;

    r.origin = mul(camera_to_world, float4(0,0,0,1)).xyz;
    r.direction = mul(inverse_projection, float4(uv.xy,0,1)).xyz;

    r.direction /= abs(r.direction.z);

    r.direction = mul(camera_to_world, float4(r.direction,0)).xyz;
    r.direction = normalize(r.direction);

    return r;
}

float rm_sceneSDF(float3 position);

//technique from http://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
float3 calculate_normal(float3 pos)
{
    const float h = 0.01;
    const float2 k = float2(h,-h);
    return normalize( k.xyy * rm_sceneSDF( pos + k.xyy ) +
                      k.yyx * rm_sceneSDF( pos + k.yyx ) +
                      k.yxy * rm_sceneSDF( pos + k.yxy ) +
                      k.xxx * rm_sceneSDF( pos + k.xxx ) );
}


float3 transformModifier(float3 position, float3 transform)
{
    return position - transform;
}

float sphereSDF(float3 position, float radius)
{
    return length(position) - radius;
}

float smoothUnion_m(float a, float b, inout float4 color_a, float4 color_b, float blend)
{
    float m = min(a, b);

    float h_dist = max(blend - abs(a - b), 0.0) / blend;
    m -= h_dist*h_dist*blend*(1.0/4.0);

    color_a = lerp(color_a, color_b, saturate(a - m));//to be optimized

    return m;
}

float smoothUnion(float a, float b, float blend)
{
    float m = min(a, b);

    float h_dist = max(blend - abs(a - b), 0.0) / blend;
    m -= h_dist*h_dist*blend*(1.0/4.0);

    return m;
}

float planeSDF(float3 position)
{
    return position.y;
}

float3 repeat(float3 position, float3 repeat)
{
    //float3 cell = floor((abs(position)+0.5*repeat)/repeat);

    return fmod(abs(position+0.5*repeat), repeat)-0.5*repeat;
}

float4 unlitMaterial(float4 color)
{
    return color;
}

float rm_sceneSDF(float3 position){
	float3 mod_position;
	float distance;
	float distance2;

	mod_position = transformModifier(position, float3(0.000, -0.500, 0.000));
	distance = planeSDF(mod_position);

	mod_position = transformModifier(position, float3(0.000, 0.000, 0.000));
	mod_position = repeat(mod_position, float3(10.000, 100.000, 10.000));
	distance2 = sphereSDF(mod_position, 2.000);
	distance = smoothUnion(distance, distance2, 3.000);

	return distance;
}

float4 rm_materialSceneSDF(float3 position){
	float3 mod_position;
	float distance;
	float distance2;

	float3 normal = calculate_normal(position);
	float4 color;
	float4 color2;

	mod_position = transformModifier(position, float3(0.000, -0.500, 0.000));
	distance = planeSDF(mod_position);
	color = unlitMaterial(float4(0.764, 0.703, 0.703, 0.000));

	mod_position = transformModifier(position, float3(0.000, 0.000, 0.000));
	mod_position = repeat(mod_position, float3(10.000, 100.000, 10.000));
	distance2 = sphereSDF(mod_position, 2.000);
	color2 = unlitMaterial(float4(0.906, 0.192, 0.192, 0.000));
	distance = smoothUnion_m(distance, distance2, color, color2, 3.000);

	return color;
}

float4 raymarch(Ray r)
{
    const int STEP = 1024;
    float dist = 0;
	for (int i = 0; i < STEP; i++)
	{
        float current_distance = rm_sceneSDF(r.origin + r.direction * dist);
		if (current_distance < 0.001f * dist)//not sure about that "* dist" bit
        {
            float4 col = rm_materialSceneSDF(r.origin + r.direction * dist);
            //col.rgb = pow(col.rgb, float3(0.4545, 0.4545, 0.4545)); //Gamma correction
            return col;
        }
        dist += current_distance;
	}

	return float4(1, 1, 0, 1);
}


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //change it later so you can blend input color depending on alpha
    Ray r = calculateRay(id.xy);
    output[id.xy] = raymarch(r);
}